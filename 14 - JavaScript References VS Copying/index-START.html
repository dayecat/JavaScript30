<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>JS Reference VS Copy</title>
  <link rel="icon" href="https://fav.farm/ğŸ”¥" />
</head>

<body>

  <script>
    // start with strings, numbers and booleans
    // æˆåŠŸè¤‡è£½a(æ•¸å­—)






    // Let's say we have an array
    const players = ['Wes', 'Sarah', 'Ryan', 'Poppy'];

    // let copy;
    // copy = players;

    // copy[0] = 'Mike'
    // copy.push('lee')
    // console.log(players);
    // console.log('===========');
    // console.log(copy);

    // let filterArray = players.filter(() = true);
    // filterArrayP[0] = 'mike'
    // console.log(players);
    // console.log('===========');
    // console.log(copy);

    let concatArray = [].concat(players);
    concatArray[0] = 'mike'
    console.log(players);
    console.log('===========');
    console.log(concatArray);

    // and we want to make a copy of it.

    // You might think we can just do something like this:

    // however what happens when we update that array?

    // now here is the problem!

    // oh no - we have edited the original array too!

    // Why? It's because that is an array reference, not an array copy. They both point to the same array!

    // So, how do we fix this? We take a copy instead!

    // one way

    // or create a new array and concat the old one in

    // or use the new ES6 Spread
    // ...ä»£è¡¨spreadçš„å¯«æ³•
    let spreadArr = [...players];
    spreadArr[0] = 'mike'
    console.log(players);
    console.log('===========');
    console.log(spreadArr);


    // now when we update it, the original one isn't changed

    // The same thing goes for objects, let's say we have a person object

    // with Objects
    const person = {
      name: 'Wes Bos',
      age: 80
    };
    // const newKey = {
    //   id: 123456,
    //   aggress:'å°ä¸­å¸‚åŒ—å€'
    // }
    // const combine = { ...person, ...newKey };
    // console.log(combine);
    // ä½¿ç”¨spread ä¾†è¤‡è£½
    let spreadObj = { ...person };
    spreadObj.name = 'mike';
    console.log(person);
    console.log(spreadObj);

    // slice
    let sliceArr = players.slice();
    sliceArr[0] = 'mike';
    // console.log(person);
    // console.log('===================');
    // console.log(sliceArr);
    // slice(param1, param2)
    // param1: å¾ç¬¬å¹¾å€‹å…ƒç´ é–‹å§‹å–è‡ªå·±è¦çš„é™£åˆ—
    // param2: å–åˆ°ç¬¬å¹¾ä½
    // å‡è¨­ç‚ºè²  EX: -2 çš„è©± ç­‰æ–¼ é™£åˆ—é•·åº¦ (6) + (-2) = 4
    //                 (-2, (é™£åˆ—é•·åº¦) )
    // let slice = arr.slice(-2, 6);
    // param1 è‹¥ä¸å¡«å¯«,å‰‡ä»¥0ä»£æ›¿ï¼›è‹¥å¤§æ–¼é™£åˆ—é•·åº¦,æœƒå¾—åˆ°ç©ºé™£åˆ—
    // param2 è‹¥ä¸å¡«å¯« å‰‡ä»¥é™£åˆ—é•·åº¦æ›¿ä»£
    let arr = [1, 2, 3, 4, 5, 6];
    let slice = arr.slice(2, 5);
    console.log(slice);
    // and think we make a copy:

    // how do we take a copy instead?

    // We will hopefully soon see the object ...spread

    // Things to note - this is only 1 level deep - both for Arrays and Objects. lodash has a cloneDeep method, but you should think twice before using it.
    const obj = {
      name: 'mike',
      address: 'å°ä¸­å¸‚',
      props: [[
        'ç­†é›»', 'æ¡Œé›»'
      ], [
        'é›»é¢¨æ‰‡', 'é¢¨æ‰‡'
      ],]
    }; 
    // const obj = {
    //   name: 'mike',
    //   address: 'å°ä¸­å¸‚',
    //   props: [
    //     'ç­†é›»', 'æ¡Œé›»'
    //   ],
    // };
    // æ·ºè¤‡è£½
    // const cp = { ...obj };
    //æ·ºå±¤çš„ä¸å—å½±éŸ¿
    // copy.name = 'lee';
    // æ·±å±¤çš„æœƒå½±éŸ¿
    // copy.props[0] = 'å£æ‰çš„ç­†é›»';
    // console.log(obj);
    // console.log(cp);

    // æ·ºè¤‡è£½
    let assign = Object.assign({}, obj);
    assign.name = 'lee';
    assign.props[0] = 'å£æ‰çš„ç­†é›»';
    console.log(assign);
    console.log(obj);
    const objjson = JSON.stringify(obj);
    const convert = JSON.parse(objjson);
    convert.name = 'lee';
    convert.props[0][0] = 'å£æ‰çš„ç­†é›»';
    convert.props[1][0] = 'å£æ‰çš„é¢¨æ‰‡';
    console.log(obj);
    console.log(convert);
  </script>

</body>

</html>